% LexiMind: A Hybrid Transformer Architecture for Multi-Task NLP
% IEEE Conference Style Paper
% Author: Oliver Perrin

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% Essential packages
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}
\usepackage{caption}

% TikZ for diagrams
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning, fit, calc, backgrounds, decorations.pathreplacing}

% Code listings style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=Python,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red!60!black},
    showstringspaces=false
}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{LexiMind: A Hybrid Transformer Architecture\\for Multi-Task Natural Language Processing}

\author{\IEEEauthorblockN{Oliver Perrin}\\
\IEEEauthorblockA{Department of Computer Science\\
Appalachian State University\\
Bachelor of Science in Computer Science\\
Email: perrinot@appstate.edu}}

\maketitle

\begin{abstract}
This paper presents LexiMind, a multi-task Natural Language Processing (NLP) system that combines a custom-built Transformer architecture with pre-trained weights from Google's FLAN-T5 (Fine-tuned Language Net Text-to-Text Transfer Transformer). The system performs three fundamental NLP tasks simultaneously: abstractive text summarization, multi-label emotion classification, and single-label topic classification. Unlike news-focused models, LexiMind specializes in literary and academic content. For summarization, we train on 49,086 samples combining Goodreads book descriptions (back-cover style blurbs) with arXiv academic paper abstracts. Emotion classification uses 43,410 samples from GoEmotions \cite{demszky2020goemotions}, a dataset of 28 fine-grained emotion labels derived from Reddit comments. Topic classification spans 3,402 samples from 20 Newsgroups, Project Gutenberg literary texts, and scientific papers across 7 categories (Fiction, Science, Technology, Philosophy, History, Psychology, Business). By implementing modern architectural innovations including Pre-Layer Normalization (Pre-LN) with Root Mean Square Layer Normalization (RMSNorm), T5-style relative position bias, FlashAttention via PyTorch 2.0's Scaled Dot-Product Attention (SDPA), gradient checkpointing, and torch.compile optimization, LexiMind achieves efficient training on consumer GPUs while maintaining strong performance. Our final model achieves a BERTScore F1 of 0.83 and ROUGE-1 of 0.31 for summarization, 85.2\% accuracy for topic classification, and F1 of 0.20 for 28-class multi-label emotion detection. The 272M-parameter architecture is constructed from first principles in a bottom-up fashion, with each component (attention mechanisms, feed-forward networks, encoder/decoder blocks) implemented as standalone modules. A factory pattern enables seamless weight transfer from FLAN-T5-base, allowing the system to leverage Google's pre-trained knowledge while maintaining full architectural transparency and customization capability.
\end{abstract}

\begin{IEEEkeywords}
Transformer, Multi-Task Learning, Natural Language Processing, FLAN-T5, Transfer Learning, Text Summarization, Emotion Classification, Academic Papers, Literary Text
\end{IEEEkeywords}

%=============================================================================
\section{Introduction}
%=============================================================================

The Transformer architecture \cite{vaswani2017attention} has fundamentally reshaped Natural Language Processing (NLP), establishing itself as the foundation for state-of-the-art models across virtually all language understanding and generation tasks. Building upon this foundation, the T5 (Text-to-Text Transfer Transformer) model \cite{raffel2020exploring} introduced a unified framework that casts all NLP problems as text-to-text transformations. FLAN-T5 (Fine-tuned Language Net) \cite{chung2022scaling} further enhanced T5's capabilities through instruction fine-tuning on over 1,000 diverse tasks.

While pre-trained models like FLAN-T5 offer impressive zero-shot and few-shot capabilities, they are often treated as black boxes—their internal mechanisms obscured by framework abstractions. This opacity hinders both understanding and customization. Furthermore, multi-task learning scenarios often require architectural modifications that pre-built models do not easily accommodate.

LexiMind addresses these challenges through a hybrid approach: implementing a complete Transformer architecture from scratch while maintaining compatibility with FLAN-T5's pre-trained weights. This provides several key advantages:

\begin{enumerate}
    \item \textbf{Architectural Transparency}: Every component—from attention mechanisms to normalization layers—is explicitly implemented and documented.
    \item \textbf{Customization Flexibility}: Task-specific heads and routing logic can be freely modified without framework constraints.
    \item \textbf{Transfer Learning}: FLAN-T5's linguistic knowledge is transferred through careful weight mapping in the factory module.
    \item \textbf{Modern Optimizations}: Integration of FlashAttention, bfloat16 training, and gradient accumulation ensures efficient resource utilization.
\end{enumerate}

A key design decision in LexiMind is the focus on literary and academic domains rather than news articles, which are overrepresented in existing summarization benchmarks. For text summarization, we combine Goodreads book descriptions---which provide back-cover style blurbs describing \textit{what a book is about}---with arXiv paper abstracts. This trains the model to generate descriptive summaries rather than extractive plot recaps. Emotion classification leverages GoEmotions \cite{demszky2020goemotions}, providing fine-grained 28-label annotations. Topic classification draws from diverse sources including 20 Newsgroups, Project Gutenberg, and scientific papers.

The contributions of this work include:
\begin{itemize}
    \item A custom Transformer implementation compatible with T5/FLAN-T5 weight loading
    \item A multi-task architecture supporting both generative (summarization) and discriminative (classification) tasks
    \item A curated dataset of 95,898 training samples across literary, academic, and conversational domains
    \item Detailed documentation of weight transfer mechanisms between pre-trained models and custom implementations
    \item Comprehensive training infrastructure with mixed-precision support, gradient monitoring, and MLflow experiment tracking
\end{itemize}

%=============================================================================
\section{Related Work}
%=============================================================================

\subsection{Transformer Architectures}

The original Transformer \cite{vaswani2017attention} introduced the self-attention mechanism, enabling parallel processing of sequences and effective capture of long-range dependencies. The architecture consists of stacked encoder and decoder blocks, each containing Multi-Head Attention (MHA) and position-wise Feed-Forward Networks (FFN).

\textbf{Layer Normalization Placement}: The original Transformer applied Layer Normalization \cite{ba2016layer} after residual connections (Post-LN). Subsequent research \cite{xiong2020layer} demonstrated that applying normalization before sublayers (Pre-LN) significantly improves training stability, particularly for deep networks. LexiMind adopts the Pre-LN configuration used by T5 and modern large language models.

\textbf{RMSNorm}: Zhang and Sennrich \cite{zhang2019root} proposed Root Mean Square Layer Normalization (RMSNorm), which removes the mean-centering operation of standard LayerNorm while maintaining comparable performance. T5 \cite{raffel2020exploring} adopts this approach, and LexiMind follows suit for compatibility.

\subsection{Pre-trained Language Models}

\textbf{T5}: Raffel et al. \cite{raffel2020exploring} introduced the T5 model, which frames all NLP tasks as text-to-text problems. T5 uses a Transformer encoder-decoder architecture with several distinctive features: relative position bias instead of absolute positional embeddings, RMSNorm for layer normalization, and a gated feed-forward network.

\textbf{FLAN-T5}: Chung et al. \cite{chung2022scaling} enhanced T5 through instruction fine-tuning, creating FLAN-T5. By training on diverse task instructions, FLAN-T5 demonstrates improved zero-shot and few-shot capabilities compared to the original T5.

\subsection{Multi-Task Learning}

Multi-Task Learning (MTL) \cite{caruana1997multitask} trains a single model on multiple related tasks, promoting parameter sharing and implicit data augmentation. Hard parameter sharing—where lower layers are shared across tasks while task-specific heads branch from shared representations—remains the dominant approach for Transformer-based MTL systems.

%=============================================================================
\section{Architecture}
%=============================================================================

LexiMind implements a complete encoder-decoder Transformer with task-specific heads, constructed using a bottom-up approach where each component is implemented as a standalone module. Figure \ref{fig:architecture} illustrates the high-level system architecture.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.75,
    transform shape,
    box/.style={draw, rectangle, minimum width=2cm, minimum height=0.7cm, align=center, rounded corners=2pt},
    smallbox/.style={draw, rectangle, minimum width=1.4cm, minimum height=0.5cm, align=center, rounded corners=2pt, font=\scriptsize},
    head/.style={draw, rectangle, minimum width=1.5cm, minimum height=0.6cm, align=center, rounded corners=2pt, fill=blue!20},
    arrow/.style={->, >=stealth, thick},
    dashedarrow/.style={->, >=stealth, dashed}
]

% Input
\node[box, fill=gray!20] (input) at (0, 0) {Input Text};

% Tokenizer
\node[box, fill=yellow!30] (tokenizer) at (0, 1.2) {Tokenizer\\(SentencePiece)};

% Encoder
\node[box, fill=green!30, minimum height=2cm] (encoder) at (0, 3.2) {Encoder\\$N=12$ layers};

% Task routing
\node[box, fill=orange!30] (router) at (0, 5.2) {Task Router};

% Decoder branch
\node[box, fill=green!30, minimum height=1.5cm] (decoder) at (-2.5, 7) {Decoder\\$N=12$ layers};
\node[head] (lmhead) at (-2.5, 8.8) {LM Head};
\node[smallbox, fill=purple!20] (summ) at (-2.5, 9.8) {Summary};

% Classification branch
\node[head] (emotionhead) at (1.2, 7) {Emotion\\Head};
\node[head] (topichead) at (2.8, 7) {Topic\\Head};
\node[smallbox, fill=purple!20] (emotion) at (1.2, 8.2) {Emotions\\(28 classes)};
\node[smallbox, fill=purple!20] (topic) at (2.8, 8.2) {Topics\\(7 classes)};

% Arrows
\draw[arrow] (input) -- (tokenizer);
\draw[arrow] (tokenizer) -- (encoder);
\draw[arrow] (encoder) -- (router);
\draw[arrow] (router) -- (decoder);
\draw[arrow] (router) -- (emotionhead);
\draw[arrow] (router) -- (topichead);
\draw[arrow] (decoder) -- (lmhead);
\draw[arrow] (lmhead) -- (summ);
\draw[arrow] (emotionhead) -- (emotion);
\draw[arrow] (topichead) -- (topic);

% Cross-attention arrow
\draw[dashedarrow] (encoder.west) -- ++(-0.5,0) |- (decoder.south west);

% Labels
\node[font=\tiny, align=center] at (-1.8, 4.5) {Cross\\Attention};

\end{tikzpicture}
\caption{LexiMind system architecture showing the shared encoder, task-specific routing, decoder for generation, and classification heads for discriminative tasks.}
\label{fig:architecture}
\end{figure}

\subsection{Transformer Block Structure}

Figure \ref{fig:transformer_block} presents the internal structure of encoder and decoder blocks, following the Pre-LN configuration from T5 \cite{raffel2020exploring}.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.65,
    transform shape,
    block/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.6cm, align=center, rounded corners=2pt},
    norm/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.5cm, align=center, fill=yellow!30, rounded corners=2pt},
    attn/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.6cm, align=center, fill=blue!25, rounded corners=2pt},
    ffn/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.6cm, align=center, fill=green!25, rounded corners=2pt},
    add/.style={draw, circle, minimum size=0.4cm, fill=red!20, inner sep=0pt, font=\small},
    arrow/.style={->, >=stealth},
]

% === ENCODER BLOCK ===
\node[font=\bfseries] at (0, 8) {Encoder Block};

% Input
\node (enc_in) at (0, 7) {};
\draw[arrow] (0, 6.5) -- (enc_in);

% RMSNorm 1
\node[norm] (enc_norm1) at (0, 6) {RMSNorm};

% Self-Attention
\node[attn] (enc_attn) at (0, 5) {Multi-Head\\Self-Attention};

% Add 1
\node[add] (enc_add1) at (0, 4) {+};

% RMSNorm 2
\node[norm] (enc_norm2) at (0, 3) {RMSNorm};

% FFN
\node[ffn] (enc_ffn) at (0, 2) {Gated FFN\\(GELU)};

% Add 2
\node[add] (enc_add2) at (0, 1) {+};

% Output
\node (enc_out) at (0, 0.3) {};

% Connections
\draw[arrow] (enc_in) -- (enc_norm1);
\draw[arrow] (enc_norm1) -- (enc_attn);
\draw[arrow] (enc_attn) -- (enc_add1);
\draw[arrow] (enc_add1) -- (enc_norm2);
\draw[arrow] (enc_norm2) -- (enc_ffn);
\draw[arrow] (enc_ffn) -- (enc_add2);
\draw[arrow] (enc_add2) -- (enc_out);

% Residual connections
\draw[arrow] (0, 6.5) -- (-1.5, 6.5) -- (-1.5, 4) -- (enc_add1.west);
\draw[arrow] (enc_add1.east) -- (1.5, 4) -- (1.5, 1) -- (enc_add2.east);

% === DECODER BLOCK ===
\node[font=\bfseries] at (5.5, 8) {Decoder Block};

% Input
\node (dec_in) at (5.5, 7) {};
\draw[arrow] (5.5, 6.5) -- (dec_in);

% RMSNorm 1
\node[norm] (dec_norm1) at (5.5, 6) {RMSNorm};

% Masked Self-Attention
\node[attn] (dec_attn1) at (5.5, 5) {Masked\\Self-Attention};

% Add 1
\node[add] (dec_add1) at (5.5, 4.2) {+};

% RMSNorm 2
\node[norm] (dec_norm2) at (5.5, 3.4) {RMSNorm};

% Cross-Attention
\node[attn, fill=cyan!25] (dec_attn2) at (5.5, 2.4) {Cross-Attention};

% Add 2
\node[add] (dec_add2) at (5.5, 1.5) {+};

% RMSNorm 3
\node[norm] (dec_norm3) at (5.5, 0.7) {RMSNorm};

% FFN
\node[ffn] (dec_ffn) at (5.5, -0.3) {Gated FFN\\(GELU)};

% Add 3
\node[add] (dec_add3) at (5.5, -1.2) {+};

% Connections
\draw[arrow] (dec_in) -- (dec_norm1);
\draw[arrow] (dec_norm1) -- (dec_attn1);
\draw[arrow] (dec_attn1) -- (dec_add1);
\draw[arrow] (dec_add1) -- (dec_norm2);
\draw[arrow] (dec_norm2) -- (dec_attn2);
\draw[arrow] (dec_attn2) -- (dec_add2);
\draw[arrow] (dec_add2) -- (dec_norm3);
\draw[arrow] (dec_norm3) -- (dec_ffn);
\draw[arrow] (dec_ffn) -- (dec_add3);

% Encoder memory input
\node[block, fill=gray!20, minimum width=1.2cm, font=\scriptsize] (memory) at (8, 2.4) {Encoder\\Memory};
\draw[arrow] (memory) -- (dec_attn2);

% Residual connections (simplified)
\draw[arrow] (5.5, 6.5) -- (4, 6.5) -- (4, 4.2) -- (dec_add1.west);
\draw[arrow] (dec_add1.east) -- (7, 4.2) -- (7, 1.5) -- (dec_add2.east);
\draw[arrow] (dec_add2.west) -- (4, 1.5) -- (4, -1.2) -- (dec_add3.west);

\end{tikzpicture}
\caption{Pre-LN Transformer blocks. Left: Encoder block with self-attention and FFN. Right: Decoder block with masked self-attention, cross-attention to encoder memory, and FFN. RMSNorm is applied \emph{before} each sublayer (Pre-LN).}
\label{fig:transformer_block}
\end{figure}

\subsection{Multi-Head Attention Mechanism}

The attention mechanism is the cornerstone of the Transformer architecture. LexiMind implements Multi-Head Attention with support for T5-style relative position bias and FlashAttention optimization. Figure \ref{fig:attention} illustrates the attention computation.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.6,
    transform shape,
    box/.style={draw, rectangle, minimum width=1.5cm, minimum height=0.6cm, align=center, rounded corners=2pt},
    proj/.style={draw, rectangle, minimum width=1.2cm, minimum height=0.5cm, align=center, fill=blue!20, rounded corners=2pt, font=\scriptsize},
    op/.style={draw, rectangle, minimum width=1.2cm, minimum height=0.5cm, align=center, fill=orange!30, rounded corners=2pt, font=\scriptsize},
    arrow/.style={->, >=stealth},
]

% Input
\node[box, fill=gray!20] (input) at (0, 0) {Input $X$};

% Projections
\node[proj] (wq) at (-2.5, 1.5) {$W_Q$};
\node[proj] (wk) at (0, 1.5) {$W_K$};
\node[proj] (wv) at (2.5, 1.5) {$W_V$};

% Q, K, V
\node[box, fill=green!20] (q) at (-2.5, 2.8) {$Q$};
\node[box, fill=green!20] (k) at (0, 2.8) {$K$};
\node[box, fill=green!20] (v) at (2.5, 2.8) {$V$};

% Split heads
\node[op] (split) at (0, 4) {Split $h$ heads};

% Attention scores
\node[op] (matmul1) at (0, 5.2) {$QK^T$};

% Position bias
\node[box, fill=yellow!30, font=\scriptsize] (bias) at (3.5, 5.2) {Relative\\Pos Bias};

% Add bias
\node[op] (add) at (0, 6.2) {$+ B_{rel}$};

% Scale (optional)
\node[op] (scale) at (0, 7.2) {Scale / Mask};

% Softmax
\node[op, fill=red!20] (softmax) at (0, 8.2) {Softmax};

% MatMul with V
\node[op] (matmul2) at (0, 9.2) {$\times V$};

% Concat
\node[op] (concat) at (0, 10.2) {Concat heads};

% Output projection
\node[proj] (wo) at (0, 11.2) {$W_O$};

% Output
\node[box, fill=purple!20] (output) at (0, 12.2) {Output};

% Arrows
\draw[arrow] (input) -- (wq);
\draw[arrow] (input) -- (wk);
\draw[arrow] (input) -- (wv);
\draw[arrow] (wq) -- (q);
\draw[arrow] (wk) -- (k);
\draw[arrow] (wv) -- (v);
\draw[arrow] (q) -- (split);
\draw[arrow] (k) -- (split);
\draw[arrow] (v.north) -- ++(0, 0.3) -| (2.5, 9.2) -- (matmul2);
\draw[arrow] (split) -- (matmul1);
\draw[arrow] (matmul1) -- (add);
\draw[arrow] (bias) -- (add);
\draw[arrow] (add) -- (scale);
\draw[arrow] (scale) -- (softmax);
\draw[arrow] (softmax) -- (matmul2);
\draw[arrow] (matmul2) -- (concat);
\draw[arrow] (concat) -- (wo);
\draw[arrow] (wo) -- (output);

% Annotations
\node[font=\tiny, align=left] at (-4.5, 5.5) {T5 does NOT\\scale by $\sqrt{d_k}$};

\end{tikzpicture}
\caption{Multi-Head Attention with T5-style relative position bias. The attention scores are computed as $QK^T + B_{rel}$, where $B_{rel}$ is the learned relative position bias. Unlike standard Transformers, T5 does not scale by $\sqrt{d_k}$.}
\label{fig:attention}
\end{figure}

The attention computation in LexiMind is implemented in \texttt{src/models/attention.py}. For T5 compatibility, the \texttt{scale\_scores} parameter controls whether to apply $\sqrt{d_k}$ scaling—T5 does not use this scaling \cite{raffel2020exploring}.

Figure \ref{fig:attention_viz} shows learned attention patterns from the trained model, demonstrating how different heads specialize in capturing various linguistic relationships.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/multihead_attention_visualization.png}
\caption{Attention weight visualization across multiple heads. Each head learns distinct attention patterns: some focus on local context (diagonal patterns), while others capture long-range dependencies and syntactic relationships.}
\label{fig:attention_viz}
\end{figure}

\subsubsection{T5 Relative Position Bias}

Unlike absolute positional embeddings that are added to token embeddings, T5 uses relative position bias added directly to attention scores. The \texttt{T5RelativePositionBias} class implements logarithmically-bucketed relative positions:

\begin{equation}
B_{ij} = \text{Embed}[\text{bucket}(i - j)]
\end{equation}

where $\text{bucket}(\cdot)$ maps relative distances to discrete buckets. Half the buckets encode exact positions for nearby tokens; the remaining half use logarithmic spacing for distant tokens. As documented in the code:

\begin{quote}
\emph{``T5 uses a combination of exact positions (for nearby tokens) and logarithmically-spaced buckets (for distant tokens).''} — \texttt{attention.py}, lines 46--48
\end{quote}

Figure \ref{fig:position_bias} visualizes the learned relative position bias, showing how the model encodes positional relationships between tokens.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/positional_encoding_heatmap.png}
\caption{Heatmap of relative position bias values. The diagonal structure indicates stronger attention between nearby positions, while the logarithmic bucketing allows efficient representation of longer-range dependencies.}
\label{fig:position_bias}
\end{figure}

\subsubsection{FlashAttention Integration}

LexiMind leverages PyTorch 2.0's \texttt{scaled\_dot\_product\_attention} function, which automatically selects the optimal attention kernel:

\begin{quote}
\emph{``Uses F.scaled\_dot\_product\_attention which automatically selects the best available kernel (FlashAttention v2, Memory-Efficient Attention, or math fallback) based on hardware and input shapes.''} — \texttt{attention.py}, lines 134--137
\end{quote}

This provides O(N) memory complexity instead of O(N²) when FlashAttention is available.

\subsection{Feed-Forward Network}

Following T5, LexiMind implements a gated feed-forward network with GELU activation:

\begin{equation}
\text{FFN}(x) = (\text{GELU}(xW_g) \odot xW_1) W_2
\end{equation}

where $W_g$ is the gating projection, $W_1$ is the up-projection, $W_2$ is the down-projection, and $\odot$ denotes element-wise multiplication.

\subsection{RMSNorm}

RMSNorm \cite{zhang2019root} normalizes inputs using only the root mean square:

\begin{equation}
\text{RMSNorm}(x) = \frac{x}{\sqrt{\frac{1}{d}\sum_{i=1}^{d}x_i^2 + \epsilon}} \cdot \gamma
\end{equation}

The implementation in \texttt{src/models/t5\_layer\_norm.py} follows T5's convention, using only a learned scale parameter $\gamma$ with no bias term.

%=============================================================================
\section{Tokenization}
\label{sec:tokenization}
%=============================================================================

LexiMind wraps HuggingFace's AutoTokenizer with a simplified façade that handles T5-specific conventions. The implementation in \texttt{src/data/tokenization.py} manages special token handling and decoder input preparation.

\subsection{T5 Tokenizer Characteristics}

T5 uses SentencePiece \cite{kudo2018sentencepiece} with unigram tokenization:

\begin{itemize}
    \item \textbf{Vocabulary Size}: 32,128 tokens (padded to multiple of 128 for efficiency)
    \item \textbf{Special Tokens}: \texttt{pad\_token\_id=0}, \texttt{eos\_token\_id=1}
    \item \textbf{No Explicit BOS}: T5 uses the pad token as the decoder start token
\end{itemize}

As noted in the tokenizer implementation:

\begin{quote}
\emph{``T5 uses different special tokens than BART: T5: pad=0, eos=1, no explicit bos (uses pad or eos as decoder start); BART: bos=0, pad=1, eos=2.''} — \texttt{tokenization.py}, lines 42--44
\end{quote}

\subsection{Decoder Input Preparation}

For seq2seq training, decoder inputs must be shifted right from labels. The \texttt{prepare\_decoder\_inputs} method handles this:

\begin{lstlisting}[caption={Decoder input preparation from tokenization.py}]
def prepare_decoder_inputs(
    self, labels: torch.Tensor
) -> torch.Tensor:
    """Shift decoder labels to create 
    input ids prefixed by BOS."""
    bos = self.bos_token_id
    pad = self.pad_token_id
    decoder_inputs = torch.full_like(labels, pad)
    decoder_inputs[:, 0] = bos
    decoder_inputs[:, 1:] = labels[:, :-1]
    return decoder_inputs
\end{lstlisting}

%=============================================================================
\section{The Factory Module: Weight Transfer from FLAN-T5}
\label{sec:factory}
%=============================================================================

The \texttt{factory.py} module is central to LexiMind's hybrid approach, providing model construction and weight loading utilities. Figure \ref{fig:factory_flow} illustrates the model construction pipeline.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.7,
    transform shape,
    box/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.7cm, align=center, rounded corners=3pt},
    config/.style={draw, rectangle, minimum width=2cm, minimum height=0.6cm, align=center, fill=yellow!30, rounded corners=2pt, font=\small},
    model/.style={draw, rectangle, minimum width=2.2cm, minimum height=0.6cm, align=center, fill=green!30, rounded corners=2pt, font=\small},
    arrow/.style={->, >=stealth, thick},
]

% Config loading
\node[config] (yaml) at (0, 0) {config.yaml};
\node[box, fill=blue!20] (loadconfig) at (0, 1.3) {load\_model\_config()};
\node[config] (modelconfig) at (0, 2.6) {ModelConfig};

% Model building
\node[box, fill=blue!20] (build) at (0, 4.2) {build\_multitask\_model()};

% Components
\node[model] (encoder) at (-2.5, 5.8) {Encoder};
\node[model] (decoder) at (0, 5.8) {Decoder};
\node[model] (heads) at (2.5, 5.8) {Task Heads};

% Weight loading
\node[box, fill=orange!30] (loadweights) at (-1.2, 7.4) {\_load\_pretrained\_weights()};

% FLAN-T5
\node[box, fill=purple!20] (flant5) at (-4, 7.4) {FLAN-T5\\(HuggingFace)};

% Final model
\node[box, fill=red!20, minimum width=3cm] (mtmodel) at (0, 9) {MultiTaskModel};

% Arrows
\draw[arrow] (yaml) -- (loadconfig);
\draw[arrow] (loadconfig) -- (modelconfig);
\draw[arrow] (modelconfig) -- (build);
\draw[arrow] (build) -- (encoder);
\draw[arrow] (build) -- (decoder);
\draw[arrow] (build) -- (heads);
\draw[arrow] (encoder) -- (loadweights);
\draw[arrow] (decoder) -- (loadweights);
\draw[arrow] (flant5) -- (loadweights);
\draw[arrow] (loadweights) -- (mtmodel);
\draw[arrow] (heads) -- (mtmodel);

\end{tikzpicture}
\caption{Model construction pipeline in \texttt{factory.py}. Configuration is loaded from YAML, components are instantiated, FLAN-T5 weights are transferred, and the final MultiTaskModel is assembled.}
\label{fig:factory_flow}
\end{figure}

\subsection{Configuration Management}

The \texttt{ModelConfig} dataclass defines all architecture hyperparameters:

\begin{lstlisting}[caption={ModelConfig from factory.py}]
@dataclass
class ModelConfig:
    d_model: int = 768
    vocab_size: Optional[int] = None
    num_encoder_layers: int = 12
    num_decoder_layers: int = 12
    num_attention_heads: int = 12
    ffn_dim: int = 2048
    dropout: float = 0.1
    use_pretrained: bool = False
    pretrained_model_name: str = 
        "google/flan-t5-base"
    activation: str = "gated-gelu"
    use_relative_position_bias: bool = False
\end{lstlisting}

\subsection{Weight Transfer Mechanism}

The \texttt{\_load\_pretrained\_weights} function performs careful weight mapping between FLAN-T5 and LexiMind's custom architecture. Key considerations documented in the code:

\begin{quote}
\emph{``T5 architecture compatibility with our custom Transformer: T5 uses Pre-LN (RMSNorm before sublayers) --- matches our design; T5 uses relative position bias instead of absolute embeddings; T5 uses gated FFN (wi\_0, wi\_1, wo); T5 attention has no bias, our attention has bias --- we zero-initialize the bias terms.''} --- \texttt{factory.py}, lines 100--108
\end{quote}

Table \ref{tab:weight_mapping} shows the parameter correspondence:

\begin{table}[htbp]
\centering
\caption{FLAN-T5 to LexiMind Weight Mapping}
\label{tab:weight_mapping}
\begin{tabular}{ll}
\toprule
\textbf{FLAN-T5 Parameter} & \textbf{LexiMind Parameter} \\
\midrule
\texttt{shared} & \texttt{encoder.embedding} \\
\texttt{encoder.block.*.SelfAttention.q} & \texttt{encoder.layers.*.self\_attn.W\_Q} \\
\texttt{encoder.block.*.SelfAttention.k} & \texttt{encoder.layers.*.self\_attn.W\_K} \\
\texttt{encoder.block.*.SelfAttention.v} & \texttt{encoder.layers.*.self\_attn.W\_V} \\
\texttt{encoder.block.*.SelfAttention.o} & \texttt{encoder.layers.*.self\_attn.W\_O} \\
\texttt{*.layer\_norm} & \texttt{*.norm*} \\
\texttt{*.DenseReluDense.wi\_0} & \texttt{*.ffn.linear\_gate} \\
\texttt{*.DenseReluDense.wi\_1} & \texttt{*.ffn.linear1} \\
\texttt{*.DenseReluDense.wo} & \texttt{*.ffn.linear2} \\
\texttt{lm\_head} & \texttt{decoder.output\_projection} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Vocabulary Size Handling}

T5 pads its vocabulary to multiples of 128 for computational efficiency (32,100 → 32,128). LexiMind handles this mismatch:

\begin{quote}
\emph{``Note: T5's vocab is padded to multiple of 128 for efficiency (32100 → 32128). [...] Copy only the tokens that exist in both. Initialize any extra tokens with small random values.''} — \texttt{factory.py}, lines 116--131
\end{quote}

\subsection{Model Assembly}

The \texttt{build\_multitask\_model} function assembles the complete system:

\begin{lstlisting}[caption={Model assembly from factory.py}]
model = MultiTaskModel(
    encoder=encoder, 
    decoder=decoder,
    decoder_outputs_logits=True
)
model.add_head(
    "summarization",
    LMHead(d_model=cfg.d_model, 
           vocab_size=vocab_size,
           tie_embedding=decoder.embedding)
)
model.add_head(
    "emotion",
    ClassificationHead(
        d_model=cfg.d_model, 
        num_labels=28,  # GoEmotions
        pooler="mean",
        hidden_dim=cfg.d_model // 2)
)
model.add_head(
    "topic",
    ClassificationHead(
        d_model=cfg.d_model,
        num_labels=7,  # 7 topic categories
        pooler="mean")
)
\end{lstlisting}

%=============================================================================
\section{Multi-Task Model Architecture}
\label{sec:multitask}
%=============================================================================

The \texttt{MultiTaskModel} class in \texttt{src/models/multitask.py} provides the routing infrastructure for multi-task learning. Figure \ref{fig:multitask_routing} illustrates the task routing mechanism.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.7,
    transform shape,
    box/.style={draw, rectangle, minimum width=2cm, minimum height=0.6cm, align=center, rounded corners=2pt},
    decision/.style={draw, diamond, aspect=2, minimum width=1.5cm, align=center, fill=yellow!30},
    arrow/.style={->, >=stealth, thick},
]

% Forward call
\node[box, fill=blue!20] (forward) at (0, 0) {forward(task, inputs)};

% Decision
\node[decision] (taskcheck) at (0, -1.5) {task type?};

% Branches
\node[box, fill=green!20] (encoder) at (-3.5, -3.5) {Encoder\\Only};
\node[box, fill=green!20] (seq2seq) at (3.5, -3.5) {Encoder\\+ Decoder};

% Heads
\node[box, fill=orange!20] (classhead) at (-3.5, -5) {Classification\\Head};
\node[box, fill=orange!20] (lmhead) at (3.5, -5) {LM Head};

% Tasks
\node[box, fill=purple!20, font=\scriptsize] (emotion) at (-5, -6.5) {Emotion};
\node[box, fill=purple!20, font=\scriptsize] (topic) at (-2, -6.5) {Topic};
\node[box, fill=purple!20, font=\scriptsize] (summ) at (3.5, -6.5) {Summarization};

% Arrows
\draw[arrow] (forward) -- (taskcheck);
\draw[arrow] (taskcheck) -- node[above, font=\scriptsize] {Classification} (encoder);
\draw[arrow] (taskcheck) -- node[above, font=\scriptsize] {Generation} (seq2seq);
\draw[arrow] (encoder) -- (classhead);
\draw[arrow] (seq2seq) -- (lmhead);
\draw[arrow] (classhead) -- (emotion);
\draw[arrow] (classhead) -- (topic);
\draw[arrow] (lmhead) -- (summ);

\end{tikzpicture}
\caption{Task routing in MultiTaskModel. Classification tasks use encoder-only processing with mean pooling, while generation tasks use the full encoder-decoder pipeline.}
\label{fig:multitask_routing}
\end{figure}

\subsection{Task-Specific Head Selection}

The forward method routes inputs based on head type:

\begin{quote}
\emph{``Encoder-only heads expect encoder outputs [...] LM/seq2seq head: run encoder → decoder → lm head''} — \texttt{multitask.py}, lines 108--148
\end{quote}

\subsection{Classification Head}

Classification tasks (emotion, topic) use mean pooling over encoder outputs:

\begin{equation}
h_{cls} = \frac{\sum_{i=1}^{L} h_i \cdot m_i}{\sum_{i=1}^{L} m_i}
\end{equation}

where $m_i$ is the attention mask (1 for valid tokens, 0 for padding). The pooled representation is projected through a linear layer to class logits.

%=============================================================================
\section{Training Pipeline}
\label{sec:training}
%=============================================================================

The training infrastructure in \texttt{src/training/trainer.py} implements a comprehensive multi-task training loop with modern deep learning practices.

\subsection{Training Configuration}

The \texttt{TrainerConfig} dataclass encapsulates all hyperparameters:

\begin{lstlisting}[caption={TrainerConfig from trainer.py}]
@dataclass
class TrainerConfig:
    max_epochs: int = 1
    gradient_clip_norm: float = 1.0
    task_weights: Dict[str, float] | None = None
    label_smoothing: float = 0.0
    gradient_accumulation_steps: int = 1
    scheduler_type: str = "cosine"
    warmup_steps: int = 0
    early_stopping_patience: int | None = None
    gradient_checkpointing: bool = False
    compile_model: bool = False
\end{lstlisting}

\subsection{Mixed-Precision Training}

LexiMind uses Automatic Mixed Precision (AMP) with automatic dtype selection:

\begin{quote}
\emph{``AMP setup: bfloat16 for Ampere+ GPUs, float16 otherwise''} — \texttt{trainer.py}, line 102
\end{quote}

BFloat16 provides better numerical stability for training while maintaining the memory and speed benefits of reduced precision.

\subsection{Learning Rate Scheduling}

A cosine schedule with linear warmup is implemented:

\begin{equation}
lr(t) = \begin{cases}
lr_{max} \cdot \frac{t}{t_{warmup}} & t < t_{warmup} \\
lr_{min} + \frac{1}{2}(lr_{max} - lr_{min})(1 + \cos(\frac{\pi(t-t_{warmup})}{T-t_{warmup}})) & t \geq t_{warmup}
\end{cases}
\end{equation}

Figure \ref{fig:lr_schedule} visualizes the learning rate schedule over training, showing the 300-step linear warmup followed by cosine decay.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/learning_rate_schedule.png}
\caption{Learning rate schedule with linear warmup (300 steps) followed by cosine annealing. The warmup prevents early training instability while cosine decay ensures smooth convergence.}
\label{fig:lr_schedule}
\end{figure}

\subsection{Multi-Task Loss Computation}

The total loss combines task-specific losses with optional weighting:

\begin{equation}
\mathcal{L}_{total} = \sum_{t \in \text{tasks}} \lambda_t \mathcal{L}_t
\end{equation}

\begin{itemize}
    \item \textbf{Summarization}: Cross-entropy with label smoothing and \texttt{ignore\_index=-100}
    \item \textbf{Emotion}: Binary Cross-Entropy with Logits (multi-label)
    \item \textbf{Topic}: Standard Cross-Entropy (single-label)
\end{itemize}

\subsection{Gradient Handling}

The trainer includes gradient clipping and early stopping:

\begin{quote}
\emph{``Gradient clipping to prevent exploding gradients [...] Early stopping based on validation loss''} — \texttt{trainer.py}
\end{quote}

\subsection{Training Loop}

Figure \ref{fig:training_loop} illustrates the training loop structure.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    scale=0.65,
    transform shape,
    box/.style={draw, rectangle, minimum width=2.5cm, minimum height=0.5cm, align=center, rounded corners=2pt, font=\small},
    arrow/.style={->, >=stealth},
]

% Epoch loop
\node[box, fill=blue!20] (epoch) at (0, 0) {For each epoch};

% Batch loop
\node[box, fill=green!20] (batch) at (0, -1.2) {For each batch};

% Task loop
\node[box, fill=yellow!20] (task) at (0, -2.4) {For each task};

% Forward
\node[box, fill=orange!20] (forward) at (0, -3.6) {Forward + Loss};

% AMP context
\node[box, fill=purple!20] (amp) at (0, -4.8) {AMP autocast};

% Backward
\node[box, fill=red!20] (backward) at (0, -6) {Backward (scaled)};

% Accumulate check
\node[box, fill=cyan!20] (accum) at (0, -7.2) {Accumulation step?};

% Optimizer step
\node[box, fill=gray!20] (optim) at (0, -8.4) {Clip + Step + Zero};

% Validation
\node[box, fill=blue!20] (val) at (3.5, -1.2) {Validation};

% Checkpoint
\node[box, fill=green!20] (ckpt) at (3.5, -2.4) {Checkpoint};

% Early stopping
\node[box, fill=red!20] (early) at (3.5, -3.6) {Early Stop?};

% Arrows
\draw[arrow] (epoch) -- (batch);
\draw[arrow] (batch) -- (task);
\draw[arrow] (task) -- (forward);
\draw[arrow] (forward) -- (amp);
\draw[arrow] (amp) -- (backward);
\draw[arrow] (backward) -- (accum);
\draw[arrow] (accum) -- (optim);
\draw[arrow] (optim.south) -- ++(0, -0.3) -| ++(-2, 0) |- (task.west);
\draw[arrow] (epoch.east) -- ++(0.5, 0) |- (val);
\draw[arrow] (val) -- (ckpt);
\draw[arrow] (ckpt) -- (early);

\end{tikzpicture}
\caption{Training loop structure showing nested iteration over epochs, batches, and tasks, with gradient accumulation and validation checkpoints.}
\label{fig:training_loop}
\end{figure}

%=============================================================================
\section{Tasks and Datasets}
%=============================================================================

LexiMind addresses three complementary NLP tasks:

\subsection{Text Summarization}

\textbf{Task}: Generate concise abstractive summaries from longer documents, focusing on back-cover style book descriptions rather than plot summaries.

\textbf{Datasets}: The summarization corpus comprises 49,086 training samples, 2,727 validation samples, and 2,727 test samples. Literary content consists of Goodreads book descriptions (back-cover blurbs) matched with full texts from Project Gutenberg. Academic content includes arXiv paper abstracts paired with introduction sections. Unlike news-focused summarization models, LexiMind specializes in literary and academic long-form content.

\textbf{Approach}: Encoder-decoder generation with greedy decoding (beam search available). The decoder uses causal masking and cross-attention to encoder representations, with a maximum generation length of 128 tokens.

\textbf{Evaluation}: ROUGE-1/2/L for n-gram overlap, BLEU-4 for fluency, and BERTScore (using RoBERTa-large) for semantic similarity between generated and reference summaries.

\subsection{Emotion Classification}

\textbf{Task}: Multi-label classification identifying emotions expressed in text, where each sample may have multiple emotion labels.

\textbf{Dataset}: Google's GoEmotions \cite{demszky2020goemotions}, comprising 43,410 training samples, 5,426 validation samples, and 5,427 test samples sourced from Reddit comments.

\textbf{Classes}: 28 emotion categories: admiration, amusement, anger, annoyance, approval, caring, confusion, curiosity, desire, disappointment, disapproval, disgust, embarrassment, excitement, fear, gratitude, grief, joy, love, nervousness, neutral, optimism, pride, realization, relief, remorse, sadness, and surprise.

\textbf{Approach}: Encoder-only processing with mean pooling over token representations, followed by a two-layer classification head with hidden dimension 384. Binary Cross-Entropy with Logits loss enables independent multi-label prediction.

\subsection{Topic Classification}

\textbf{Task}: Single-label classification assigning documents to one of seven topic categories.

\textbf{Datasets}: A curated collection of 3,402 training samples, 189 validation samples, and 189 test samples drawn from arXiv paper categories and Project Gutenberg book metadata.

\textbf{Classes}: 7 mutually exclusive topics: Arts, Business, Fiction, History, Philosophy, Science, and Technology.

\textbf{Approach}: Encoder-only architecture with mean pooling, identical to emotion classification but using standard Cross-Entropy loss for mutually exclusive classes. Due to the significantly smaller dataset (3.4K vs 43K for emotion), the topic loss weight is reduced to 0.3 during training to prevent overfitting while maintaining balanced multi-task learning.

%=============================================================================
\section{Model Specifications}
%=============================================================================

Table \ref{tab:dataset_summary} summarizes the dataset splits used for training and evaluation. Table \ref{tab:model_specs} details the model architecture.

\begin{table}[htbp]
\centering
\caption{Dataset Summary}
\label{tab:dataset_summary}
\begin{tabular}{lccc}
\toprule
\textbf{Task} & \textbf{Train} & \textbf{Val} & \textbf{Test} \\
\midrule
Summarization & 49,086 & 2,727 & 2,727 \\
Emotion & 43,410 & 5,426 & 5,427 \\
Topic & 3,402 & 189 & 189 \\
\midrule
\textbf{Total} & 95,898 & 8,342 & 8,343 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\caption{LexiMind Model Specifications}
\label{tab:model_specs}
\begin{tabular}{lc}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Hidden dimension ($d_{model}$) & 768 \\
FFN dimension ($d_{ff}$) & 2048 \\
Attention heads & 12 \\
Head dimension & 64 \\
Encoder layers & 12 \\
Decoder layers & 12 \\
Vocabulary size & 32,128 \\
Max sequence length & 512 \\
Dropout & 0.1 \\
Activation & Gated-GELU \\
Normalization & RMSNorm (Pre-LN) \\
Position encoding & Relative bias \\
\midrule
Total parameters & $\sim$272M \\
\bottomrule
\end{tabular}
\end{table}

%=============================================================================
\section{Implementation Details}
%=============================================================================

\subsection{Project Structure}

LexiMind follows a modular architecture:

\begin{verbatim}
src/
+-- models/
|   +-- attention.py     # MHA, RelPosBias
|   +-- encoder.py       # Encoder blocks
|   +-- decoder.py       # Decoder blocks  
|   +-- heads.py         # Task heads
|   +-- multitask.py     # MTL routing
|   +-- factory.py       # Construction
+-- data/
|   +-- tokenization.py  # Tokenizer
|   +-- dataset.py       # Dataset classes
|   +-- dataloader.py    # Collators
+-- training/
    +-- trainer.py       # Training loop
    +-- metrics.py       # Evaluation
scripts/
+-- train.py             # Main training
+-- download_data.py     # Dataset download
+-- inference.py         # CLI inference
+-- demo_gradio.py       # Web demo
\end{verbatim}

\subsection{FlashAttention and CUDA Optimizations}

The trainer enables comprehensive hardware-specific optimizations:

\begin{lstlisting}[caption={CUDA optimizations from train.py}]
if device.type == "cuda":
    torch.backends.cudnn.benchmark = True
    torch.backends.cuda.matmul.allow_tf32 = True
    torch.backends.cudnn.allow_tf32 = True
    torch.backends.cuda.enable_flash_sdp(True)
    torch.backends.cuda.enable_mem_efficient_sdp(
        True)
\end{lstlisting}

Note that T5-style relative position bias is incompatible with FlashAttention, as FlashAttention requires adding bias tensors to attention scores which breaks the fused kernel. The development configuration disables relative position bias to enable FlashAttention for faster iteration, while production configurations retain relative position bias for better quality.

\subsection{Numerical Stability}

To prevent overflow during mixed-precision training, hidden states are clamped after each sublayer:

\begin{quote}
\emph{``Clamp inf values for fp16/bf16 training stability (like HuggingFace T5)''} — \texttt{encoder.py}, lines 103--105
\end{quote}

%=============================================================================
\section{Experimental Setup}
%=============================================================================

\subsection{Training Configuration}

The final training configuration was optimized for quality and efficiency on an NVIDIA RTX 4070 with 12GB VRAM:

\begin{itemize}
    \item \textbf{Optimizer}: Fused AdamW with weight decay 0.01, $\beta_1=0.9$, $\beta_2=0.98$
    \item \textbf{Learning Rate}: $3 \times 10^{-5}$ with cosine decay
    \item \textbf{Warmup}: 300 steps ($\sim$0.5 epochs)
    \item \textbf{Batch Size}: 10 with 4$\times$ gradient accumulation (effective batch size 40)
    \item \textbf{Precision}: BFloat16 on Ampere+ GPUs with TF32 enabled
    \item \textbf{Gradient Clipping}: Max norm 1.0
    \item \textbf{Gradient Checkpointing}: Enabled for memory efficiency
    \item \textbf{torch.compile}: Dynamic compilation for encoder and decoder
    \item \textbf{Task Weights}: Summarization 1.0, Emotion 1.0, Topic 0.3 (reduced due to small dataset)
    \item \textbf{Early Stopping}: Patience of 3 epochs on validation loss
    \item \textbf{Encoder Freezing}: Bottom 4 layers frozen for stable transfer learning
\end{itemize}

Training completed in 7 epochs ($\sim$6 hours) with early stopping triggered due to validation loss plateau.

%=============================================================================
\section{Experimental Results}
\label{sec:results}
%=============================================================================

We evaluate LexiMind on held-out validation sets for each task. Table \ref{tab:summarization_results} presents the summarization metrics, Table \ref{tab:classification_results} shows classification performance.

\subsection{Summarization Performance}

\begin{table}[htbp]
\centering
\caption{Summarization Evaluation Results}
\label{tab:summarization_results}
\begin{tabular}{lc}
\toprule
\textbf{Metric} & \textbf{Score} \\
\midrule
ROUGE-1 & 0.3064 \\
ROUGE-2 & 0.0896 \\
ROUGE-L & 0.1832 \\
BLEU-4 & 0.0237 \\
\midrule
BERTScore Precision & 0.8430 \\
BERTScore Recall & 0.8179 \\
\textbf{BERTScore F1} & \textbf{0.8300} \\
\bottomrule
\end{tabular}
\end{table}

The BERTScore F1 of \textbf{0.83} demonstrates strong semantic similarity between generated descriptions and references, indicating the model captures meaning effectively even when exact wording differs. ROUGE scores are typical for abstractive summarization where the model paraphrases rather than extracts verbatim text.

\subsection{Classification Performance}

\begin{table}[htbp]
\centering
\caption{Classification Evaluation Results}
\label{tab:classification_results}
\begin{tabular}{llc}
\toprule
\textbf{Task} & \textbf{Metric} & \textbf{Score} \\
\midrule
\multirow{2}{*}{Topic (7 classes)} & Accuracy & \textbf{85.19\%} \\
 & Macro F1 & 0.8474 \\
\midrule
Emotion (28 classes) & Multi-label F1 & 0.1987 \\
\bottomrule
\end{tabular}
\end{table}

Topic classification achieves \textbf{85.2\%} accuracy with balanced per-class performance. The emotion detection task proves more challenging due to the 28-class multi-label setting with inherent label ambiguity in the GoEmotions dataset.

\subsection{Training Dynamics}

Figure \ref{fig:training_curves} illustrates the training dynamics over 7 epochs. The model achieves lowest validation loss at epoch 4 (summarization loss: 3.698), with the checkpoint from this epoch saved as the best model. Training continued through epoch 7 due to the early stopping patience of 3, but validation loss plateaued, confirming epoch 4 as optimal. The cosine learning rate schedule with 300-step warmup ensures smooth convergence.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/training_loss_curve.png}
\caption{Training and validation loss curves over 7 epochs. Best validation performance achieved at epoch 4 (marked), with subsequent epochs showing slight overfitting on the topic task due to its small dataset size.}
\label{fig:training_curves}
\end{figure}

Figure \ref{fig:task_metrics} presents per-task metrics throughout training, showing the distinct learning trajectories for summarization, emotion detection, and topic classification.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/task_metrics.png}
\caption{Task-specific metrics during training: ROUGE-1 for summarization, F1 for emotion detection, and accuracy for topic classification.}
\label{fig:task_metrics}
\end{figure}

Figure \ref{fig:training_dynamics} provides a comprehensive view of training dynamics, including loss convergence, per-epoch improvements, cumulative loss reduction, and the train-validation gap which indicates overfitting behavior.

\begin{figure}[htbp]
\centering
\includegraphics[width=\columnwidth]{figures/training_dynamics.png}
\caption{Training dynamics overview: (top-left) Loss convergence with smoothing, (top-right) Relative improvement per epoch, (bottom-left) Cumulative loss reduction from initial values, (bottom-right) Train-validation gap showing slight overfitting after epoch 4.}
\label{fig:training_dynamics}
\end{figure}

\subsection{Per-Class Topic Analysis}

Table \ref{tab:topic_breakdown} shows the per-class performance for topic classification:

\begin{table}[htbp]
\centering
\caption{Per-Class Topic Classification Performance}
\label{tab:topic_breakdown}
\begin{tabular}{lccc}
\toprule
\textbf{Topic} & \textbf{Precision} & \textbf{Recall} & \textbf{F1} \\
\midrule
Arts & 0.93 & 0.76 & 0.84 \\
Business & 0.97 & 0.97 & 0.97 \\
Fiction & 0.95 & 1.00 & 0.97 \\
History & 0.83 & 0.78 & 0.81 \\
Philosophy & 0.80 & 0.86 & 0.83 \\
Science & 0.58 & 0.73 & 0.65 \\
Technology & 0.86 & 0.89 & 0.87 \\
\bottomrule
\end{tabular}
\end{table}

The model performs best on Fiction and Business categories, while Science shows the most confusion, likely due to overlap with Technology topics.

%=============================================================================
\section{Discussion}
%=============================================================================

\subsection{Key Findings}

\textbf{BERTScore vs. ROUGE}: The high BERTScore F1 (0.83) combined with moderate ROUGE-1 (0.31) illustrates a key characteristic of abstractive summarization. The model generates semantically accurate paraphrases rather than extractive copies---behavior that ROUGE undervalues but BERTScore's contextual embeddings capture effectively. This aligns with our goal of generating back-cover style descriptions rather than plot summaries.

\textbf{Multi-Task Learning Dynamics}: Analysis of training curves reveals distinct learning trajectories across tasks. Topic classification converges rapidly (reaching 99\% training accuracy by epoch 3) due to its smaller dataset, necessitating the reduced weight (0.3) to prevent gradient dominance. Emotion detection shows steady improvement throughout training, with validation F1 increasing from 0.30 to 0.40. Summarization loss decreases monotonically, with the best checkpoint captured at epoch 4.

\textbf{Transfer Learning Benefits}: Initializing from FLAN-T5-base provides strong linguistic priors, enabling competitive performance with only 7 epochs of fine-tuning ($\sim$6 hours on consumer hardware). Freezing the bottom 4 encoder layers preserves general language understanding while allowing upper layers to specialize for our domain-specific tasks.

\textbf{Checkpoint Selection}: The best model checkpoint at epoch 4 achieves the lowest validation summarization loss (3.698) while maintaining strong classification performance. Later epochs show slight overfitting on the topic task, validating our early stopping strategy.

\subsection{Limitations}

\begin{itemize}
    \item \textbf{Emotion Detection}: The 28-class multi-label setting remains challenging, with F1 of 0.20 on validation data. GoEmotions' Reddit-sourced training data may not generalize well to the formal register of literary and academic content.
    \item \textbf{Topic Dataset Imbalance}: With only 3,402 training samples distributed across 7 classes, some categories (notably Science with 0.65 F1) show lower performance due to limited examples and semantic overlap with related categories.
    \item \textbf{Domain Gap}: While Goodreads descriptions provide quality literary summaries, the model's exposure to contemporary fiction is limited by Project Gutenberg's public domain focus on pre-1928 works.
\end{itemize}

\subsection{Future Work}

Several directions could improve LexiMind's performance:
\begin{itemize}
    \item \textbf{Domain-Specific Emotion Data}: Fine-tuning on literary emotion annotations rather than Reddit comments could better capture the emotional nuances of literary and academic text.
    \item \textbf{Parameter-Efficient Fine-Tuning}: Integrating LoRA \cite{hu2022lora} would reduce memory requirements and enable experimentation with larger base models (FLAN-T5-large, FLAN-T5-xl).
    \item \textbf{Expanded Topic Dataset}: Augmenting the 3.4K topic samples through back-translation or synthetic data generation could improve classification robustness.
\end{itemize}

%=============================================================================
\section{Conclusion}
%=============================================================================

This paper presented LexiMind, a multi-task NLP system combining custom Transformer implementation with FLAN-T5 pre-trained weights. The hybrid approach provides architectural transparency while leveraging transfer learning, achieving:

\begin{itemize}
    \item \textbf{Summarization}: BERTScore F1 of 0.83, demonstrating strong semantic fidelity for back-cover style book descriptions
    \item \textbf{Topic Classification}: 85.2\% accuracy and 0.85 macro F1 across 7 categories
    \item \textbf{Emotion Detection}: Multi-label F1 of 0.20 on 28 emotion classes
\end{itemize}

The complete system trains in approximately 6 hours on a consumer GPU (RTX 4070 12GB), demonstrating that sophisticated multi-task models remain accessible without datacenter-scale resources. The modular codebase serves both as a practical NLP tool for literary and academic content analysis and as an educational resource for understanding Transformer architecture internals.

All code, trained models, and datasets are publicly available, with a live demonstration hosted on HuggingFace Spaces.\footnote{\url{https://huggingface.co/spaces/OliverPerrin/LexiMind}}

%=============================================================================
% References
%=============================================================================

\begin{thebibliography}{00}

\bibitem{vaswani2017attention}
A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, Ł. Kaiser, and I. Polosukhin, ``Attention is all you need,'' in \textit{Advances in Neural Information Processing Systems (NeurIPS)}, vol. 30, 2017, pp. 5998--6008. [Online]. Available: \url{https://arxiv.org/abs/1706.03762}

\bibitem{raffel2020exploring}
C. Raffel, N. Shazeer, A. Roberts, K. Lee, S. Narang, M. Matena, Y. Zhou, W. Li, and P. J. Liu, ``Exploring the limits of transfer learning with a unified text-to-text transformer,'' \textit{Journal of Machine Learning Research}, vol. 21, no. 140, pp. 1--67, 2020. [Online]. Available: \url{https://arxiv.org/abs/1910.10683}

\bibitem{chung2022scaling}
H. W. Chung, L. Hou, S. Longpre, B. Zoph, Y. Tay, W. Fedus, Y. Li, X. Wang, M. Dehghani, S. Brahma, A. Webson, S. S. Gu, Z. Dai, M. Suzgun, X. Chen, A. Chowdhery, A. Castro-Ros, M. Pellat, K. Robinson, D. Valter, S. Narang, G. Mishra, A. Yu, V. Zhao, Y. Huang, A. Dai, H. Yu, S. Petrov, E. H. Chi, J. Dean, J. Devlin, A. Roberts, D. Zhou, Q. V. Le, and J. Wei, ``Scaling instruction-finetuned language models,'' \textit{arXiv preprint arXiv:2210.11416}, 2022. [Online]. Available: \url{https://arxiv.org/abs/2210.11416}

\bibitem{xiong2020layer}
R. Xiong, Y. Yang, J. He, K. Zheng, S. Zheng, C. Xing, H. Zhang, Y. Lan, L. Wang, and T. Liu, ``On layer normalization in the transformer architecture,'' in \textit{International Conference on Machine Learning (ICML)}, 2020, pp. 10524--10533. [Online]. Available: \url{https://arxiv.org/abs/2002.04745}

\bibitem{zhang2019root}
B. Zhang and R. Sennrich, ``Root mean square layer normalization,'' in \textit{Advances in Neural Information Processing Systems (NeurIPS)}, vol. 32, 2019, pp. 12360--12371. [Online]. Available: \url{https://arxiv.org/abs/1910.07467}

\bibitem{ba2016layer}
J. L. Ba, J. R. Kiros, and G. E. Hinton, ``Layer normalization,'' \textit{arXiv preprint arXiv:1607.06450}, 2016. [Online]. Available: \url{https://arxiv.org/abs/1607.06450}

\bibitem{caruana1997multitask}
R. Caruana, ``Multitask learning,'' \textit{Machine Learning}, vol. 28, no. 1, pp. 41--75, 1997.

\bibitem{kudo2018sentencepiece}
T. Kudo and J. Richardson, ``SentencePiece: A simple and language independent subword tokenizer and detokenizer for neural text processing,'' in \textit{Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations}, 2018, pp. 66--71. [Online]. Available: \url{https://arxiv.org/abs/1808.06226}

\bibitem{hu2022lora}
E. J. Hu, Y. Shen, P. Wallis, Z. Allen-Zhu, Y. Li, S. Wang, L. Wang, and W. Chen, ``LoRA: Low-rank adaptation of large language models,'' in \textit{International Conference on Learning Representations (ICLR)}, 2022. [Online]. Available: \url{https://arxiv.org/abs/2106.09685}

\bibitem{dao2022flashattention}
T. Dao, D. Fu, S. Ermon, A. Rudra, and C. Ré, ``FlashAttention: Fast and memory-efficient exact attention with IO-awareness,'' in \textit{Advances in Neural Information Processing Systems (NeurIPS)}, vol. 35, 2022, pp. 16344--16359. [Online]. Available: \url{https://arxiv.org/abs/2205.14135}

\bibitem{zhang2019bertscore}
T. Zhang, V. Kishore, F. Wu, K. Q. Weinberger, and Y. Artzi, ``BERTScore: Evaluating text generation with BERT,'' in \textit{International Conference on Learning Representations (ICLR)}, 2020. [Online]. Available: \url{https://arxiv.org/abs/1904.09675}

\bibitem{demszky2020goemotions}
D. Demszky, D. Movshovitz-Attias, J. Ko, A. Cowen, G. Nemade, and S. Ravi, ``GoEmotions: A dataset of fine-grained emotions,'' in \textit{Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics}, 2020, pp. 4040--4054. [Online]. Available: \url{https://arxiv.org/abs/2005.00547}

\end{thebibliography}

\end{document}
